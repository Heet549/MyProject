# -*- coding: utf-8 -*-
"""Threeeq.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wok2IoPlOLt2X9FD0zBPlwlUU1OPNOBk
"""

# solve_and_plot_planes.py
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # registers 3D projection
from matplotlib import cm

def read_equation(prompt):
    while True:
        try:
            vals = input(prompt).strip().split()
            if len(vals) != 4:
                raise ValueError("Enter exactly 4 numbers: a b c d")
            a, b, c, d = map(float, vals)
            return a, b, c, d
        except Exception as e:
            print("Invalid input:", e)

def compute_solution(A, B):
    # try a linear solve, but handle singular matrices
    try:
        sol = np.linalg.solve(A, B)
        return sol, "unique"
    except np.linalg.LinAlgError:
        # either infinite solutions or no solution; check ranks
        rankA = np.linalg.matrix_rank(A)
        rankAug = np.linalg.matrix_rank(np.column_stack((A, B)))
        if rankA == rankAug:
            return None, "infinite"
        else:
            return None, "inconsistent"

def plane_z(a, b, c, d, X, Y):
    # returns Z grid for plane ax + by + cz = d
    # if c == 0, return None to indicate vertical plane or no z function
    if abs(c) < 1e-12:
        return None
    return (d - a*X - b*Y) / c

def main():
    print("Enter coefficients for each plane in the form: a b c d  (representing ax + by + cz = d)")
    a1, b1, c1, d1 = read_equation("Equation 1: ")
    a2, b2, c2, d2 = read_equation("Equation 2: ")
    a3, b3, c3, d3 = read_equation("Equation 3: ")

    A = np.array([[a1, b1, c1],
                  [a2, b2, c2],
                  [a3, b3, c3]], dtype=float)
    B = np.array([d1, d2, d3], dtype=float)

    sol, status = compute_solution(A, B)
    if status == "unique":
        print("Unique solution (x, y, z):", sol)
    elif status == "infinite":
        print("System has infinitely many solutions (planes intersect along a line or overlap).")
    else:
        print("System is inconsistent (no common intersection).")

    # Prepare mesh grid for plotting. Choose range centered on the solution if unique.
    if sol is not None:
        cx, cy = sol[0], sol[1]
        r = 5.0
        x = np.linspace(cx - r, cx + r, 50)
        y = np.linspace(cy - r, cy + r, 50)
    else:
        # fallback range
        x = np.linspace(-5, 5, 50)
        y = np.linspace(-5, 5, 50)

    X, Y = np.meshgrid(x, y)

    Z1 = plane_z(a1, b1, c1, d1, X, Y)
    Z2 = plane_z(a2, b2, c2, d2, X, Y)
    Z3 = plane_z(a3, b3, c3, d3, X, Y)

    fig = plt.figure(figsize=(10,7))
    ax = fig.add_subplot(111, projection='3d')

    # Plot each plane only if Z is available (c != 0)
    planes = [(Z1, 'Plane 1', cm.viridis),
              (Z2, 'Plane 2', cm.plasma),
              (Z3, 'Plane 3', cm.inferno)]

    for Z, label, cmap in planes:
        if Z is None:
            # For planes with c==0, plot them as vertical meshes: solve for x or y if possible
            # Example: ax + by + 0*z = d  -> a*x + b*y = d  (a vertical plane in z)
            # We'll sample z and one of x/y.
            print(f"{label}: vertical plane (z not a function). Drawing an approximate patch.")
            # attempt to solve for x = (d - b*y)/a if a != 0 else solve for y
            if abs(a1) > 1e-12 and label == 'Plane 1':
                xs = (d1 - b1*y) / a1
                Xv, Zv = np.meshgrid(xs, np.linspace(-5, 5, 2))
                Yv = np.tile(y, (2,1))
                ax.plot_surface(Xv, Yv, Zv, alpha=0.25)
            # (For simplicity, only handle common easy vertical-case in detail.)
        else:
            surf = ax.plot_surface(X, Y, Z, alpha=0.45, cmap=cmap, linewidth=0, antialiased=True)
            surf._edgecolor2d = surf._edgecolor3d
            surf._facecolor2d = surf._facecolor3d
            # label by adding a small surface legend marker
            # (Matplotlib 3D has no easy legend for surfaces; we'll add text)
            # Find a point to put the label:
            xi = X.ravel()[len(X.ravel())//2]
            yi = Y.ravel()[len(Y.ravel())//2]
            zi = Z.ravel()[len(Z.ravel())//2]
            ax.text(xi, yi, zi, label, color='k')

    # Plot solution point if it exists
    if sol is not None:
        ax.scatter([sol[0]], [sol[1]], [sol[2]], color='k', s=60, marker='o', edgecolors='g', label='Intersection')
        ax.text(sol[0], sol[1], sol[2], f'  ({sol[0]:.2f}, {sol[1]:.2f}, {sol[2]:.2f})', color='k')

    ax.set_xlabel('X axis')
    ax.set_ylabel('Y axis')
    ax.set_zlabel('Z axis')
    ax.set_title('Three Planes and Their Intersection (if any)')
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()